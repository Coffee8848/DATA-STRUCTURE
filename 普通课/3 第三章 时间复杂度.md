# 算法效率

### 用n指问题规模

worsrTime（n）最坏时间复杂度  *解决问题最多的步骤*

averageTime （n）平均时间复杂度 *指平均执行的操作数量*

这两个都是关于n的函数

例如

```cpp
for (int i =0;i<n i++) {
   if (a[i]>i)
    cout<<i<<endl;}
```

这里的最坏时间复杂度 是4n+2

1. `int i = 0;`
   * 初始化变量 `i`，执行一次。
2. `i < n;`
   * 每次循环开始时检查条件，执行 `n + 1` 次（包括最后一次检查失败）。
3. `i++`
   * 每次循环结束时递增 `i`，执行 `n` 次。
4. `if (a[i] > i)`
   * 条件检查，执行 `n` 次。
5. `cout << i << endl;`
   * 只有在条件为真时才执行，最坏情况下执行 `n` 次。

平均时间复杂度是3n+2

* 初始化 `i`：1 次
* 条件检查 `i < n`：`n + 1` 次
* 递增 `i`：`n` 次
* 条件检查 `a[i] > i`：`n` 次
* 输出 `cout << i << endl`：平均情况下 `n / 2` 次

### 用一个上界函数来表示复杂度

用最简单的函数来表示复杂程度

*Big O表示法关注的是算法的最坏情况性能。*

> 引入大O（order）

*我们可以说 `f(n) = 3n^2 + 2n + 1` 是 `O(n^2)`。

1. **O(1)**: 常数时间复杂度。算法的运行时间不随输入规模的变化而变化。
2. **O(log n)**: 对数时间复杂度。算法的运行时间随输入规模的对数增长。
3. **O(n)**: 线性时间复杂度。算法的运行时间与输入规模成正比。
4. **O(n log n)**: 线性对数时间复杂度。常见于一些高效的排序算法，如归并排序和快速排序。
5. **O(n^2)**: 平方时间复杂度。常见于一些简单的排序算法，如冒泡排序、选择排序和插入排序。
6. **O(2^n)**: 指数时间复杂度。常见于一些递归算法，如解决汉诺塔问题。
7. **O(n!)**: 阶乘时间复杂度。常见于一些排列组合问题，如旅行商问题的暴力解法。

### 常量时间复杂度 O（1）

```cpp
for(int i, i<1000 ,i++){
print
}
```

例如一个与n无关的一个for循环

> 链表的插入操作也是

O（1）   //例如直接访问数组

### 线性时间复杂度 O（n）

```cpp
for(int i, i<n ,i++){
balablabablaal
}
def constant_time_operation():
    x = 1 + 1
    return x
```

O（n）//例如遍历数组

例如

> 数组的插入操作的时间复杂度

只用去算循环次数就可以了   不用计算一次循环中多少步骤

递归也是 只用计算递归次数 不用计入一次递归做过什么

### 平方时间复杂度 O(n^2)

例如冒泡排序

```cpp
void bubbleSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}  // O(n^2)
```

外部循环n次 内部循环n次 量级n^2次

### 对数时间复杂度 O（log n）

```cpp
while （n>1)
n = n/2;
```

例如 n 为8 执行三次循环

即使n不是2的整指数也就只多一次运算

复杂度为 O(log2 n) 所有对数的量级都一直  所以为

> O （log n ）

以后凡是对数复杂度*不需要写底数。*

### 还有立方 指数等复杂度

### 做题技巧

就去看循环 嵌套(比如冒泡排序)还是并列

### **3. 有效判断时间复杂度的方法**

#### **观察代码结构**

1. **单循环：O(n)O(n)**O**(**n**)**
   * 循环范围是 00**0** 到 nn**n**，每次执行基本操作。
2. **嵌套循环：O(nk)O(n^k)**O**(**n**k**)****
   * 外层和内层循环嵌套，循环次数相乘。
   * 两层循环：O(n2)O(n^2)**O**(**n**2**)**，三层循环：O(n3)O(n^3)**O**(**n**3**)**。
3. **分治法：O(nlog⁡n)O(n \\log n)**O**(**n**log**n**)**
   * 每次将问题规模缩小一半，如归并排序、快速排序。
4. **对数时间：O(log⁡n)O(\\log n)**O**(**lo**g**n**)**
   * 问题规模以指数形式减少，如二分查找。
5. **并列循环：根据单独循环的复杂度判断**
   * 如果两个循环是独立的，则时间复杂度是两者的较大值。

# 随机数

### 伪随机数

c和cpp产生的rand函数就是伪随机数 其实随机数序列是确定的 不具有真正的随机性

但这样的随机数便于实验科学研究和计算 但是严格的抽奖 密码等领域 不可以使用伪随机数
