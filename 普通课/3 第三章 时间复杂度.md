# 算法效率

### 用n指问题规模

worsrTime（n）最坏时间复杂度  *解决问题最多的步骤*

averageTime （n）平均时间复杂度 *指平均执行的操作数量*

这两个都是关于n的函数

例如

```cpp
for (int i =0;i<n i++) {
   if (a[i]>i)
    cout<<i<<endl;}
```

这里的最坏时间复杂度 是4n+2

1. `int i = 0;`
   * 初始化变量 `i`，执行一次。
2. `i < n;`
   * 每次循环开始时检查条件，执行 `n + 1` 次（包括最后一次检查失败）。
3. `i++`
   * 每次循环结束时递增 `i`，执行 `n` 次。
4. `if (a[i] > i)`
   * 条件检查，执行 `n` 次。
5. `cout << i << endl;`
   * 只有在条件为真时才执行，最坏情况下执行 `n` 次。

平均时间复杂度是3n+2

* 初始化 `i`：1 次
* 条件检查 `i < n`：`n + 1` 次
* 递增 `i`：`n` 次
* 条件检查 `a[i] > i`：`n` 次
* 输出 `cout << i << endl`：平均情况下 `n / 2` 次

### 用一个上界函数来表示复杂度

用最简单的函数来表示复杂程度

> 引入大O（order）

*定义* *：如果存在正数常数 `c` 和 `n0`，使得对于所有 `n >= n0`，都有 `f(n) <= c * g(n)`，那么我们说 `f(n)` 是 `O(g(n))`，记作 `f(n) = O(g(n))`。*

假设我们有一个算法，其时间复杂度为 `f(n) = 3n^2 + 2n + 1`。我们可以用大O表示法来描述其增长率。

1. 选择 `g(n)` ：
   * 我们选择 `g(n) = n^2`，因为 `n^2` 是 `f(n)` 中增长最快的项。
2. **验证 `f(n) <= c * g(n)`**：
   * 我们需要找到常数 `c` 和 `n0`，使得对于所有 `n >= n0`，都有 `3n^2 + 2n + 1 <= c * n^2`。
   * 选择 `c = 6` 和 `n0 = 1`，可以验证对于所有 `n >= 1`，都有 `3n^2 + 2n + 1 <= 6n^2`。

因此，我们可以说 `f(n) = 3n^2 + 2n + 1` 是 `O(n^2)`。

### 常量时间复杂度 O（1）

```cpp
for(int i, i<1000 ,i++){
print
}
```

例如一个与n无关的一个for循环

> 链表的插入操作也是

O（1）

### 线性时间复杂度 O（n）

```cpp
for(int i, i<n ,i++){
balablabablaal
}
```

O（n）

例如

> 数组的插入操作的时间复杂度

只用去算循环次数就可以了   不用计算一次循环中多少步骤

递归也是 只用计算递归次数 不用计入一次递归做过什么

### 平方时间复杂度 O(n^2)

例如冒泡排序

```cpp
void bubbleSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}  // O(n^2)
```

外部循环n次 内部循环n次 量级n^2次

### 对数时间复杂度 O（log n）

```cpp
while （n>1)
n = n/2;
```

例如 n 为8 执行三次循环

即使n不是2的整指数也就只多一次运算

复杂度为 O(log2 n) 所有对数的量级都一直  所以为

> O （log n ）

以后凡是对数复杂度不需要写底数。

### 还有立方 指数等复杂度

### 做题技巧

就去看循环 嵌套还是并列

# 随机数

### 伪随机数

c和cpp产生的rand函数就是伪随机数 其实随机数序列是确定的 不具有真正的随机性

但这样的随机数便于实验科学研究和计算 但是严格的抽奖 密码等领域 不可以使用伪随机数
