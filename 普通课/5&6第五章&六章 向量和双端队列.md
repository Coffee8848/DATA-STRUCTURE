> 向量 链表 和 双端队列 是三种容器

# 向量

## 引入

向量在STL中已定义好

向量指一组连续的元素 向量在cpp里几乎就是数组 但是向量可以使用标准模板库实现更强的的功能

> 可以说使用cpp时候 能用向量就不用使用数组了

1. 向量可以随机访问
2. 在序列*后*的删除和添加只需要常量时间复杂度(平均情况下(最坏情况需要扩容 扩容需要把所有的元素复制一遍需要*O(n)*))

##### 向量作为一个容器的特点/数组没有的功能

1. 可以确定元素个数
2. 可以自动改变大小
3. 可以支持下标运算
4. 向量可以在任意位置插入和删除元素
5. 可以把一个向量赋值给另一个向量   数组不能直接a=b
6. 向量类是模板类 元素类型可以在*使用时*指定  数组必须在*定义时*就制定元素类型
7. 向量虽然有了这么多功能但是和数组一样高效

## 向量的功能

### 使用向量

`include<vector>`

### 常用的方法

`vector<T> weights` 构造向量

`vector<int> copy = original;` 拷贝构造

`vector(<int> n);`指定元素个数的构造器

`copy = original;`赋值运算

> 以下用weight做向量名的例子

`weight.push_back(const T& x)`向后插入向量 (涉及扩容 最坏时间复杂度为O(n) 平均时间复杂度是O(1) )

> push指将数据放入容器

`weight insert( iterator position,const T& value) `

`weight.pop_back();`删除向量最后段的元素 时间复杂度O(1)

`weight.erase(itr);` 删除指定位置 最坏和平均时间复杂度O(n)

`weight.rease(weight.begin(),weight.end())` 删除指定范围的元素 例子中使是所有元素 删除到end()的下一个 时间复杂度同上

```cpp
  vector<string>words;
string word;

for(int i = 0 ;i < 5; i++)
{
  cin >> word
  words.push_back(word)
}
word.erase(word.begin());
words.pop_back();
for(unsigned i = 0; i < words.size(); i++)
  cout <<word[i]<<<endl;

```

> unsigned 用来声明一个无符号整数类型 这里是标准库的约定和惯例   当成int就行

## 向量的实现

惠普的经典实现:

向量的物理存储机制是动态数组 为了方便进行向量操作 向量还有三个指针

### 核心: 三个指针

`start ` 指向第一个元素的位置

`finish `  指向最后一个元素的***后一个空的位置***

`end_of_storage` 指向分配的内存空间的末尾位置 *这个位置就不属于向量里面了*

```bash
start                finish               end_of_storage
  |                    |                        |
  v                    v                        v
+----+----+----+----+----+----+----+----+----+
| 1  | 2  | 3  | 4  |    |    |    |    |    |  
+----+----+----+----+----+----+----+----+----+
```

> 结构决定算法

## 向量的应用

高精度的算数运算

例如RSA加密需要处理非常大的整数甚至超过long 解决方法:

> 逐数位存在向量里

设计一个`very_long_integer`类

# 双端队列 deque

理解: 双端数组

是一种允许在两端进行插入和删除操作的线性数据结构

## 特点

* **双端操作**：可以在队列的两端进行插入和删除操作。
* **随机访问**：支持随机访问 并且是常数时间复杂度.
* **动态大小**：可以根据需要自动调整大小。
* **内存不连续**：与 `std::vector` 不同，`std::deque` 的元素存*储在多个内存*块中，但提供类似数组的接口。

## 常用操作

* **插入操作**：

  * `push_back`：末尾添加元素。
  * `push_front`：前端添加元素.
    平均时间复杂度是常量
* **删除操作**：

  * `pop_back`：移除末尾元素。(向量不能直接删除首元素)
  * `pop_front`：移除前端元素。
* **访问操作**：

  * `operator[]`：访问元素。
  * `at`：随机访问元素，并进行边界检查。
  * `front`：访问前端的元素。
  * `back`：访问末尾的元素。
* **容量操作**：

  * `size`：返回队列中的元素数量。
  * `empty`：检查队列是否为空。
  * `clear`：移除所有元素。

  ## 链表(复习和补充)

  ### 复习双向链表

  在双向链表（或一般的链表）中，`insert` 方法通常会在指定迭代器所指向的位置之前插入新元素。这是因为插入操作需要保持链表的顺序，并且在链表中插入元素时，最常见的操作是将新元素插入到现有元素之前。


  > 注意 插入操作 insert约定是往前插入代码   使用的时候  例如`words.insert(itr, "good");` 而不更新 `itr`，那么 `itr` 仍然指向原来的位置，只是它之前多了一个新插入的元素。
  >

  > itr = words .insert (itr,good)  这样才会添加完元素把迭代器指向插入的新元素的位置
  > 以下是示例
  >

  ```cpp
  #include <iostream>

  struct Node {
      int data;
      Node* next;
      Node* prev;
      Node(int val) : data(val), next(nullptr), prev(nullptr) {}
  };

  class CircularDoublyLinkedList {
  public:
      CircularDoublyLinkedList() : head(nullptr) {}

      // 在链表末尾添加节点（即在头节点之前插入节点）
      void append(int val) {
          Node* newNode = new Node(val);
          if (!head) {
              head = newNode;
              head->next = head;
              head->prev = head;
          } else {
              Node* tail = head->prev;
              tail->next = newNode;
              newNode->prev = tail;
              newNode->next = head;
              head->prev = newNode;
          }
      }

      // 在指定位置之前插入节点
      void insert(Node* pos, int val) {
          Node* newNode = new Node(val);
          Node* prevNode = pos->prev;
          prevNode->next = newNode;
          newNode->prev = prevNode;
          newNode->next = pos;
          pos->prev = newNode;
      }

      void printForward() {
          if (!head) return;
          Node* current = head;
          do {
              std::cout << current->data << " ";
              current = current->next;
          } while (current != head);
          std::cout << std::endl;
      }

      void printBackward() {
          if (!head) return;
          Node* current = head->prev;
          do {
              std::cout << current->data << " ";
              current = current->prev;
          } while (current != head->prev);
          std::cout << std::endl;
      }

      Node* getHead() {
          return head;
      }

  private:
      Node* head;
  };

  int main() {
      CircularDoublyLinkedList cdll;
      cdll.append(1);
      cdll.append(2);
      cdll.append(3);

      std::cout << "Forward: ";
      cdll.printForward();

      std::cout << "Backward: ";
      cdll.printBackward();

      // 在头节点之前插入新节点（即在链表末尾添加节点）
      Node* head = cdll.getHead();
      cdll.insert(head, 4);

      std::cout << "After inserting 4 before head (at the end):" << std::endl;
      std::cout << "Forward: ";
      cdll.printForward();

      std::cout << "Backward: ";
      cdll.printBackward();

      return 0;
  }
  ```
