# 递归（recursive）

函数执行过程中调用自身   递归关键在于确保每次递归调用都使问题规模减小，并且最终达到基准情况递归要朝着结束的条件递归 不能无限调用

如果问题可以用递归解决那就可以用循环解决

#### 递归的一般形式

```cpp
if 最简形式
  // 直接解决
  else 
 //进行递归变成更简单的形式 
```

思路

1. 能不能直接解决的最简形式
2. 复杂的问题能不能变成更简单形式

#### 一个例子 求阶乘

阶乘 最简单的情况  0和1的阶乘是1  当n    != 1 时 n！= n x（n-1）

```cpp
long f(int n) {
    if (n == 1 || n == 0) {
        return 1;
    } else {
        return n * f(n - 1);
    }
}
```

求阶乘的时间复杂度是O（n）

空间复杂度： 每递归一次就多分配一个空间存储n，需要的空间和递归次数成正比 所以 空间复杂度也是（n）?

#### 另一个例子 十进制转换二进制

方法：除以2取余数

```cpp
int  f (int n) {
 if (n == 1 | n == 0 )
  cout << n;
 else {
  f(n/2);// 这里应该先写递归再写输出  因为2进制要让余数从最后面得输出 先递归是倒序输出 先输出是正序数
  cout << n % 2;
}
 }

```

#### 回溯

递归通常都是深度优先的
