# 红黑树

红黑树是第二种平衡的二叉搜索树(第一种是avl树)

红黑树也是一种二叉搜索树与二叉搜索树的插入删除有关

红黑树不平衡时会旋转进行调整 与旋转有关

> 查找、插入和删除操作的时间复杂度为O(log n)。

### 红黑树的特点

> 根的颜色是黑色   其他每个节点的颜色是红色或者黑色 每个NIL节点是黑色 (空节点)

除了以上两规则 红黑树的所有性质可以简化为两条核心规则:

1. 红色规则:一个红色的节点不能有红色的孩子(红色的节点不能连续,红色节点的子节点是黑色)
2. 路径规则:从根到任何一个节点的*只有一个孩子*或*没有孩子*的节点的路径上的黑色节点的数量要相同

根的颜色是黑色

根的颜色是黑色

根的颜色是黑色

#### 数的最小高度

$$
最小高度(完全黑色数):log_2(n+1)   最大高度(最多红色节点):2倍最小高度
$$

也有 最长路径不超过最短路径的两倍 avl是不超过1

## 红黑树的旋转

旋转是为了符合红色规则和路径规则

https://www.bilibili.com/video/BV1Xm421x7Lg/

## 红黑树的运算算法

总结部分精准空降 https://www.bilibili.com/video/BV1Xm421x7Lg?t=674.5

查找运算直接使用二叉树即可  不需要修改

自增运算(迭代器)不需要修改

以上都是因为红黑树也是二叉搜索树

插入删除需要修改

### 插入

> 插入节点默认为红色 因为如果为黑色插入必然会违反第二条规则   这样子减少了需要调整的概率

### 插入操作步骤

1. 按BST方式插入并着为红色
2. 修复红色规则违反（根据三种情况）

   插入有三规则破坏情况:

   1. 叔叔红 对叔叔 爷 父亲翻转色 然后把爷爷当做插入节点 继续查看是否违反规则    每次调整完都需要到爷爷那里判定

      > 1. 注 叔叔是父旁边的  如果没有 那就是隐藏的空 看做黑色
      >
   2. 叔叔黑  按照AVL树的旋转操作判定和进行 LL RR LR RL 旋转

      1. 然后对旋转中心轴点和旋转的点进行反色
      2. RL LR型的话   按照最后一次旋转对旋转中心轴点和旋转的点反色(也可以理解成先转化为LL RR型才进行的旋转)

---

### **红黑树删除**

### **删除操作的基本步骤**

/1.

**初始删除**：按照二叉搜索树（BST）的方式删除节点。

1. 只有左子树/右子树的情况

   1. 此时直接让孩子代替后变黑

   > 1. 红黑树因为自身性质 只有左/右子树和的情况只能是上黑下红  红在左or右这两种情况
   >

   没有孩子直接看图吧

https://www.bilibili.com/video/BV16m421u7Tb 我草我放弃 太难

<!--

### **需要调整的情况**

当被删除的节点是黑色叶子节点，或者被删除的节点有两个子节点且替换节点是黑色叶子节点时，就需要进行额外的调整。这是因为删除一个黑色节点可能会导致红黑树的**黑高**（从根节点到叶子节点的黑色节点数量）不平衡。

### **调整思路**

- **定义节点 x 和 w**：
  - 令 `x` 为替代被删除节点的位置的节点（可能是一个 NIL 节点，视为黑色）。
  - 令 `w` 为 `x` 的兄弟节点（与 `x` 同父的另一子节点）。
- **目标**：
  - 通过重新着色和旋转，恢复红黑树的平衡性，确保所有路径上的黑色节点数量相同。
- **调整过程**：
  - 通过一个循环，不断调整树，直到满足红黑树的性质。循环的结束条件是 `x` 是红色节点，或者 `x` 是根节点。
  - 在循环中，根据 `x` 和 `w` 的情况，分类讨论，进行相应的处理。

### **四种情况（当 x 是左子节点时）**

1. **情况 1：w 是红色**

   - **现象**：`w` 节点为红色，`x` 为黑色节点。
   - **处理**：
     - 将 `w` 着色为黑色。
     - 将 `x` 的父节点着色为红色。
     - 对 `x` 的父节点进行左旋。
     - 这样处理后，新的兄弟节点 `w` 为黑色，转化为情况 2、3 或 4。
   - **目的**：将红色的兄弟节点转换为黑色，以便应用后面的情况。
2. **情况 2：w 是黑色，且 w 的两个子节点都是黑色**

   - **现象**：`w` 和 `w` 的子节点都是黑色。
   - **处理**：
     - 将 `w` 着色为红色。
     - 将 `x` 的父节点作为新的 `x`，向上继续检查。
   - **目的**：减少 `x` 所在路径上的黑色节点数，可能需要继续向上调整。
3. **情况 3：w 是黑色，w 的左子节点为红色，右子节点为黑色**

   - **现象**：`w` 是黑色，`w` 的左子节点为红色，右子节点为黑色。
   - **处理**：
     - 将 `w` 的左子节点着色为黑色。
     - 将 `w` 着色为红色。
     - 对 `w` 进行右旋。
     - 处理后，新的兄弟节点 `w` 满足情况 4。
   - **目的**：通过旋转，使得兄弟节点 `w` 的右子节点为红色，以便应用情况 4。
4. **情况 4：w 是黑色，且 w 的右子节点为红色**

   - **现象**：`w` 是黑色，`w` 的右子节点为红色。
   - **处理**：
     - 将 `w` 的颜色设置为 `x` 的父节点的颜色。
     - 将 `x` 的父节点着色为黑色。
     - 将 `w` 的右子节点着色为黑色。
     - 对 `x` 的父节点进行左旋。
     - 调整完成，退出循环。
   - **目的**：通过旋转和重新着色，平衡树的黑高，恢复红黑树的性质。

### **示例解析**

#### **示例 1：删除节点 40**

- **初始树**：
  ```
      50
     /  \
    40  70
          \
          120
  ```
- **操作**：
  - 删除节点 40，`x` 为 NIL 节点，`w` 为节点 70。
  - `w` 为黑色，`w` 的子节点中有红色节点，应用相应的调整策略。

#### **示例 2：删除节点 120（有两个子节点）**

- **初始树**：
  ```
       100
      /    \
     40    120
    /     /   \
   30    110  135
         /
        105
  ```
- **操作**：
  - 用后继节点 135 替换 120，被删除的节点是黑色，`x` 为 NIL，`w` 为节点 110。
  - 需要进行调整以恢复红黑树的性质。

#### **示例 3：删除节点 100（根节点）**

- **初始树**：
  ```
      100
     /    \
    40    120
   /  \
  30   80
  /
  10
  ```

**操作**：

- 用后继节点 120 替换 100，`x` 为 NIL，`w` 为节点 40。
- 需要调整以确保根节点为黑色，且红黑树的性质被维护。

### **调整的循环过程**

- **循环条件**：当 `x` 不是根节点，且 `x` 为黑色时，继续循环。
- **在循环中**：
- 根据 `x` 和 `w` 的颜色和子节点情况，选择上述四种情况之一进行处理。
- 处理后，可能需要更新 `x` 和 `w`，继续下一次循环。

### **调整结束**

- **循环结束条件**：`x` 为红色节点，或 `x` 为根节点。
- **操作**：将 `x` 着色为黑色。
- **结果**：红黑树的性质被恢复，删除操作完成。

### **时间复杂度分析**

- **最坏情况**：调整过程可能需要沿树向上遍历，全树高度为 `O(log n)`，因此最坏情况时间复杂度为 `O(log n)`。
- **平均情况**：大多数情况下，调整只需常数次操作，平均时间复杂度为 `O(1)`。
- **摊销时间复杂度**：由于红黑树的高效性，删除操作的摊销时间复杂度为 `O(1)`。

---

**总结**

红黑树删除操作复杂但有章可循，通过细致地分类讨论不同的情况，应用相应的旋转和重新着色操作，可以有效地维护红黑树的平衡性。理解每种情况的处理方法，有助于深入掌握红黑树的工作原理，确保在实际应用中正确地实现红黑树的删除操作。

## 例题

让我们详细分析删除节点40的情况，并展示每个步骤和相应的调整。

### 初始树结构

```
        40
       /  \
     30    60
    /  \   /  \
   20  35 50  80
  / \  / \
 10 25 32 37
```

### 删除节点40

1. **找到替换节点**：节点40有两个子节点，因此我们需要找到其后继节点来替换它。后继节点是右子树中的最小节点，即节点50。
2. **替换节点40**：用节点50替换节点40。

### 替换后的树结构

```
        50
       /  \
     30    60
    /  \     \
   20  35    80
  / \  / \
 10 25 32 37
```

### 调整过程

1. **删除节点40后，x和w的初始状态**：
   - `x` 是替换节点的位置，即节点50的位置。
   - `w` 是 `x` 的兄弟节点，即节点60。

### 四种情况的处理

#### 情况1：w是红色

- **现象**：`w` 节点为红色，`x` 为黑色节点。
- **处理**：
  - 将 `w` 着色为黑色。
  - 将 `x` 的父节点着色为红色。
  - 对 `x` 的父节点进行左旋。
  - 更新 `w` 为 `x` 父节点的右子节点。

在这个例子中，`w` 是黑色，所以不适用情况1。

#### 情况2：w是黑色，且w的两个子节点都是黑色

- **现象**：`w` 和 `w` 的子节点都是黑色。
- **处理**：
  - 将 `w` 着色为红色。
  - 将 `x` 指向其父节点，继续向上检查。

在这个例子中，`w` 的子节点80是红色，所以不适用情况2。

#### 情况3：w是黑色，w的左子节点为红色，右子节点为黑色

- **现象**：`w` 是黑色，`w` 的左子节点为红色，右子节点为黑色。
- **处理**：
  - 将 `w` 的左子节点着色为黑色。
  - 将 `w` 着色为红色。
  - 对 `w` 进行右旋。
  - 处理后，新的兄弟节点 `w` 满足情况4。

在这个例子中，`w` 的右子节点80是红色，所以不适用情况3。

#### 情况4：w是黑色，且w的右子节点为红色

- **现象**：`w` 是黑色，`w` 的右子节点为红色。
- **处理**：
  - 将 `w` 的颜色设置为 `x` 的父节点的颜色。
  - 将 `x` 的父节点着色为黑色。
  - 将 `w` 的右子节点着色为黑色。
  - 对 `x` 的父节点进行左旋。
  - 调整完成，退出循环。

在这个例子中，`w` 的右子节点80是红色，所以适用情况4。

### 调整后的树结构

```
        50
       /  \
     30    60
    /  \     \
   20  35    80
  / \  / \
 10 25 32 37
```

通过上述步骤，我们成功删除了节点40，并通过重新着色和旋转操作，确保红黑树的性质得以维护。
-->

## 应用 基于红黑树实现的四种容器类的作用

`map`、`set`、`multiset` 和 `multimap` 基于**红黑树**来实现的。依靠红黑树的**平衡性**来保证 O(log n) 的平均操作复杂度。



| **容器**   | **键是否唯一** | **值是否唯一** | **键值对** | **用途**           |
| ---------- | -------------- | -------------- | ---------- | ------------------ |
| `map`      | 是             | 是             | 是         | 快速查找键值对     |
| `set`      | 是             | 是             | 否         | 存储唯一值         |
| `multimap` | 否             | 否             | 是         | 允许键重复的键值对 |
| `multiset` | 否             | 否             | 否         | 存储可以重复的值   |


#### 1. map

##### 1.1 作用

* **键值对储存**：`map` 是一个按键排序（key-sorted）的关联式容器，每个元素都包含一个“键(key)”和一个与之关联的“值(value)”。
* **键的唯一性**：`map` 保证所有键都是**唯一**的。如果在插入相同键时，默认不会创建新元素，而是更新现有键对应的值。
* **有序性**：所有元素按照键的大小顺序自动排序，可以通过迭代器顺序访问，顺序即为键从小到大的顺序。

##### 1.2 使用场景

* **需要按键快速查找**且**键不允许重复**：例如需要按姓名(键)快速找到某位学生的成绩(值)，并且不允许出现重名键。
* **需要保持键有序**：在遍历时希望得到一个按键排序的序列。

#### 2. set

##### 2.1 作用

* **只储存键，没有值**：`set` 里的元素即为键。每个插入到 `set` 的元素都根据红黑树节点来存储，不需要任何额外的值信息。
* **键的唯一性**：`set` 保证所有元素（即键）都是**唯一**的，重复插入相同的元素会被忽略。
* **有序性**：`set` 中的元素按照其大小（通过比较运算）自动排序，遍历时即可得到一个有序序列。

##### 2.2 使用场景

* **只关注数据集合中是否存在某元素**，不需要储存额外信息。
* **需要保持元素有序**，且不允许重复。

#### 3. multiset

##### 3.1 作用

* **只储存键，没有值**：与 `set` 相同，本质上就是一棵红黑树，只不过允许键重复。
* **允许键重复**：`multiset` 允许相同的元素出现多次（即重复插入同样的元素不会被忽略）。
* **有序性**：同样会按照元素的大小进行自动排序，多个相同的元素会在排序中相邻出现。

##### 3.2 使用场景

* **需要一个有序的数据集合**，但**允许元素出现多个副本**。
* 比如统计一个序列中各个数字出现的次数，并且要保持它们有序。

#### 4. multimap

##### 4.1 作用

* **键值对储存**：和 `map` 类似，每个元素都包含一个键和一个值。
* **允许键重复**：与 `map` 不同之处在于，如果插入两个相同的键，`multimap` 会分别保存它们，不会发生覆盖。
* **有序性**：同样基于红黑树，根据键的大小进行自动排序。

##### 4.2 使用场景

* **需要按键进行快速查找**，但是**同一个键可能对应多个值**。
* **需要保持所有键有序**：如果有多个相同键，遍历时会将这些键对应的值放在一起，并按照键的排序位置依次出现。

```cpp
#include <map>       // map 的头文件
#include <set>       // set 的头文件
#include <string>    // 如果需要存储 string 值
#include <iostream>  // 输出演示

// 声明一个 key 为 int, value 为 std::string 的 map
std::map<int, std::string> myMap {
    {1, "Apple"},
    {2, "Banana"},
    // 插入时也可直接写 {3, "Cherry"} 等
};

// 声明一个整型 set
std::set<int> mySet { 10, 20 };
// 如果插入重复元素（比如再次插入 10），set 不会插入成功

// 函数中演示如何使用它们
void map_set_usage_demo() 
{
    // (1) map 的插入
    myMap[3] = "Cherry";          // 通过下标操作符插入(或覆盖)一个键值对
    myMap.insert({4, "Durian"});  // 使用 insert() 插入新的元素
    // 如果插入相同 key, 会覆盖旧 value:
    myMap[2] = "Blueberry";       // 原本是 "Banana"，现在变成 "Blueberry"

    // (2) map 的查找
    auto itM = myMap.find(2);     // find(2) 返回 key=2 的迭代器
    if (itM != myMap.end()) {
        std::cout << "Found key=2, value=" << itM->second << std::endl;
    }

    // (3) map 的删除
    myMap.erase(1);               // 按 key=1 删除
    // 或者先 find(key) 再用 erase(it) 按迭代器删除

    // (4) map 的遍历（元素按 key 升序排序）
    std::cout << "[map elements] ";
    for (auto &kv : myMap) {
        std::cout << "(" << kv.first << ", " << kv.second << ") ";
    }
    std::cout << std::endl;

    // -------------------------------

    // (1) set 的插入
    mySet.insert(30);
    mySet.insert(20); // 20 已存在，插入失败，set 不会重复存储

    // (2) set 的查找
    auto itS = mySet.find(30);
    if (itS != mySet.end()) {
        std::cout << "Found 30 in mySet" << std::endl;
    }

    // (3) set 的删除
    mySet.erase(10);   // 如果 10 存在则删除
    // 同理可先 find() 再按迭代器 erase() 

    // (4) set 的遍历（元素按升序排序）
    std::cout << "[set elements] ";
    for (auto &elem : mySet) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
}


```
