# 二叉树

二叉树是一种树形数据结构，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。二叉树的结构使其在许多算法和数据结构中非常有用，特别是在搜索、排序和表达式解析等领域。

### 二叉树的基本概念

1. **节点（Node）**：二叉树的基本单元，每个节点包含一个值和两个指向子节点的引用。
2. **根节点（Root）**：树的顶端节点，没有父节点。
3. **叶节点（Leaf）**：没有子节点的节点。
4. **子节点（Child）**：一个节点的直接后继节点。
5. **父节点（Parent）**：一个节点的直接前驱节点。
6. **左子节点（Left Child）**：一个节点的左侧子节点。
7. **右子节点（Right Child）**：一个节点的右侧子节点。
8. **高度（Height）**：从节点到叶节点的最长路径上的边数。
9. **深度（Depth）**：从根节点到该节点的路径上的边数。

### 二叉树的类型

1. **满二叉树（Full Binary Tree）**：每个节点要么有两个子节点，要么没有子节点。
2. **完全二叉树（Complete Binary Tree）**：除了最后一层，所有层都是满的，且最后一层的节点尽可能靠左。
3. **平衡二叉树（Balanced Binary Tree）**：任何节点的两个子树的高度差不超过1。
4. **二叉搜索树（Binary Search Tree, BST）**：对于每个节点，左子树的所有节点值小于该节点值，右子树的所有节点值大于该节点值。

### 二叉树的遍历

1. **前序遍历（Pre-order Traversal）**：根节点 -> 左子树 -> 右子树
2. **中序遍历（In-order Traversal）**：左子树 -> 根节点 -> 右子树
3. **后序遍历（Post-order Traversal）**：左子树 -> 右子树 -> 根节点
4. **层次遍历（Level-order Traversal）**：按层次从上到下，从左到右遍历

### 空树（Empty Tree）

空树是指没有任何节点的树。它是二叉树的一种特殊情况，通常用于表示树的结束或初始化状态。

### 满二叉树（Full Binary Tree）

满二叉树是一种特殊的二叉树，其中每个节点要么有两个子节点，要么没有子节点。换句话说，所有的非叶子节点都有两个子节点，所有的叶子节点都在同一层次上。

#### 特点：

1. 每一层的节点数都是最大值。
2. 如果满二叉树的高度为 `h`，则节点总数为 `2^h - 1`。

### 完全二叉树（Complete Binary Tree）

完全二叉树是一种二叉树，其中除了最后一层，所有层都是满的，并且最后一层的节点尽可能靠左排列。

#### 特点：

1. 从根节点到倒数第二层，所有层都是满的。
2. 最后一层的节点从左到右依次排列，没有空缺。

### 完美二叉树（Perfect Binary Tree）

完美二叉树是一种特殊的满二叉树，其中所有的叶子节点都在同一层次上，并且每个非叶子节点都有两个子节点。

#### 特点：

1. 所有叶子节点都在同一层次上。
2. 每个非叶子节点都有两个子节点。
3. 如果完美二叉树的高度为 `h`，则节点总数为 `2^h - 1`。

### 平衡二叉树（Balanced Binary Tree）

平衡二叉树是一种二叉树，其中任何节点的两个子树的高度差不超过1。平衡二叉树的目的是保持树的高度尽可能低，从而提高操作的效率。

#### 特点：

1. 任意节点的左右子树高度差不超过1。
2. 常见的平衡二叉树有AVL树和红黑树。

### 二叉搜索树（Binary Search Tree, BST）

二叉搜索树是一种特殊的二叉树，其中每个节点的左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。

#### 特点：

1. 左子树的所有节点值小于根节点值。
2. 右子树的所有节点值大于根节点值。
3. 中序遍历二叉搜索树可以得到一个递增的有序序列。

这个示例展示了如何创建满二叉树、完全二叉树和二叉搜索树。

# 二叉搜索树

二叉搜索树是一种特殊的二叉树，其中每个节点的左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。

二叉搜索树与满二叉树、完全二叉树 等没有直接关系

`每一个子树都是如此`

### 特点

从左到右有序 ----`一定存在最小的元素在最左  一定存在的最大的元素在最右`

### 插入元素的步骤

所有的元素都可以放入二叉搜索树

1. 从根节点开始。
2. 如果树是空的，则新节点作为根节点。
3. 否则，比较新节点的值与当前节点的值：
   * 如果新节点的值小于当前节点的值，递归地在左子树插入。
   * 如果新节点的值大于当前节点的值，递归地在右子树插入。

### 实现二叉搜索树

关联容器-元素的位置取决于它与已存在的元素的关系    不取决于放入先后 时间

```cpp
class BinSearchTree{
  peivate:
    unsigned size() const;
iterator search()// 平均 O(log n) 最坏O(n)
iterator insert(const T& item)//不需要位置 平均时间复杂log 最坏O(n)
void delete//平均时间复杂度常量  最坏On
//以上  最换的情况都是所有节点都在一个直线上
iterator end()   //end返回的是最大的元素的迭代器
iterator begin() //注意begin返回的是最小元素的迭代器
~BinSearchTree()//析构器
}
```
