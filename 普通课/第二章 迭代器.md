# 第二章

## 迭代器

### 嵌套迭代器

```cpp

 class Iterator {
    public:
        Iterator(Node* node) : current(node) {}

        // 重载解引用运算符
        int& operator*() {
            return current->data;
        }

        // 重载前置++运算符
        Iterator& operator++() {
            if (current) {
                current = current->next;
            }
            return *this;
        }

        // 重载不等运算符
        bool operator!=(const Iterator& other) const {
            return current != other.current;
        }
```

### 迭代器类型

1.输入（input）迭代器: 迭代器只能从前往后单向移动 

需要支持的运算 * ++ == （例如链表的迭代器）

```cpp
 // 重载解引用运算符
        int& operator*() {
            return current->data;
        }

        // 重载前置++运算符
        Iterator& operator++() {
            if (current) {
                current = current->next;
            }
            return *this;
        }

        // 重载不等运算符
        bool operator!=(const Iterator& other) const {
            return current != other.current;
        }
```

2.双向（bi-dimentional）迭代器：顾名思义

于单向迭代器增加 自减运算 （链表只有next的指针不能简单的实现自减运算 *链表实现自减结构意义不大*）


3.随机访问迭代器：迭代器可以直接进行算术运算直接访问需要

只能基于连续结构如数组（*数组的指针就是随机访问迭代器*）

## 析构器

系统自动构建的析构**不会**删除整个链表 需要自己定义*析构器* 不然会*内存泄露*

```cpp
~LinkedList() {
    Node* current = head;
    while (current) {
        Node* nextNode = current->next;
        delete current;//delete是关键词用来删除new分配的内存
        current = nextNode;
    }
}
// 只用一个一个删除节点就行了
```

## 泛型/通用 算法

旨在用一套代码操作各种**容器**（*指各种数据结构类型*） 前提是数据类型用泛型定义


#### 通用的泛型查找算法 find

只要该容器满足输入迭代器 那么就可以用它查找任何容器里的指定值

```cpp
template <class 输入迭代器，class T> 
输入迭代器 find(输入迭代器 first， 输入迭代器 last,const T& value）//first和last定义查找范围  是[)半开结构 第一个包括最后一个不包括 
//第三个参数是要寻找的值
{
 while (frist !=last && *frist != value) ++first；//迭代器单向移动
 return first;//根据返回值判断是否找到 如果返回值是last的值那么没找到
}
```
